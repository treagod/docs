{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grip is a microframework for building RESTful web applications. It is designed to be modular and easy to use, with the ability to scale up to the limits of the Crystal programming language. It offers extensibility and it has integrated middleware called \"pipes\" which alter the parts of the request/response context and pass it on to the actual endpoint. It has a router which somewhat resembles that of Phoenix framework 's router and most of all it is fast, peaking at 1,663,946 requests/second for plain text response. Project structure \u00b6 For example a project structure of a normal Grip application should look like this: # In this example the project name is `Echo` lib/ # Library src/ application.cr # Entry file echo/ # Business logic, database interaction, etc. ... echo_web/ # Web layer to interact with the business layer. views/ # Views directory ... controllers/ # Controllers directory ... shards.yml # The package configuration file","title":"Prelude"},{"location":"#project-structure","text":"For example a project structure of a normal Grip application should look like this: # In this example the project name is `Echo` lib/ # Library src/ application.cr # Entry file echo/ # Business logic, database interaction, etc. ... echo_web/ # Web layer to interact with the business layer. views/ # Views directory ... controllers/ # Controllers directory ... shards.yml # The package configuration file","title":"Project structure"},{"location":"advanced_routing/","text":"The more advanced the route is the more time it takes when executed, since the call to the index function is an indirect call, meaning that the index/1 never existed in the Grip::Controllers::Http class it needs to be wrapped in a Proc which then needs to be called. class AuthorizationHandler include HTTP :: Handler def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context context . put_req_header ( \"Authorization\" , \"Bearer eyMANEmJeFF=\" ) end end class DemoController < Grip :: Controllers :: Http def index ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes pipeline :api , [ AuthorizationHandler . new ] pipeline :web , [ HTTP :: CompressHandler . new ] # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. # # You can route the request through unlimited amounts of pipelines. scope \"/\" do pipe_through :web pipe_through :api get \"/\" , DemoController , as : :index end scope \"/api\" do pipe_through :api scope \"/v1\" do get \"/\" , DemoController , as : :index end end end end","title":"Advanced routing"},{"location":"application/","text":"Application class is a building class which initializes the crucial parts of the web-framework, it contains the main handler stack and the HTTP server. Available methods \u00b6 host/0 root/0 custom/0 port/0 reuse_port/0 router/0 server/0 key_file/0 cert_file/0 run/0 host \u00b6 The host of the server. class Application < Grip :: Application def host : String \"127.0.0.1\" end end root \u00b6 The root handlers inserted before the Exception handler. class Application < Grip :: Application def root : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end custom \u00b6 The custom handlers inserted after the Exception handler. class Application < Grip :: Application def custom : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end port \u00b6 The port of the server. class Application < Grip :: Application def port : Int32 6969 end end reuse_port \u00b6 The reuse_port boolean of the server. class Application < Grip :: Application def reuse_port : Bool true end end router \u00b6 The router of the application. class Application < Grip :: Application def router : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end server \u00b6 The server of the application. class Application < Grip :: Application def server : HTTP :: Server HTTP :: Server . new ( router ) end end key_file \u00b6 The key_file of the application. class Application < Grip :: Application def key_file : String \"SSL_KEY_FILE_LOCATION\" end end cert_file \u00b6 The cert_file of the application. class Application < Grip :: Application def cert_file : String \"SSL_CERTIFICATE_FILE_LOCATION\" end end run \u00b6 The run of the application executes the main application loop.","title":"Application"},{"location":"application/#available-methods","text":"host/0 root/0 custom/0 port/0 reuse_port/0 router/0 server/0 key_file/0 cert_file/0 run/0","title":"Available methods"},{"location":"application/#host","text":"The host of the server. class Application < Grip :: Application def host : String \"127.0.0.1\" end end","title":"host"},{"location":"application/#root","text":"The root handlers inserted before the Exception handler. class Application < Grip :: Application def root : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end","title":"root"},{"location":"application/#custom","text":"The custom handlers inserted after the Exception handler. class Application < Grip :: Application def custom : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end","title":"custom"},{"location":"application/#port","text":"The port of the server. class Application < Grip :: Application def port : Int32 6969 end end","title":"port"},{"location":"application/#reuse_port","text":"The reuse_port boolean of the server. class Application < Grip :: Application def reuse_port : Bool true end end","title":"reuse_port"},{"location":"application/#router","text":"The router of the application. class Application < Grip :: Application def router : Array ( HTTP :: Handler ) [] of HTTP :: Handler end end","title":"router"},{"location":"application/#server","text":"The server of the application. class Application < Grip :: Application def server : HTTP :: Server HTTP :: Server . new ( router ) end end","title":"server"},{"location":"application/#key_file","text":"The key_file of the application. class Application < Grip :: Application def key_file : String \"SSL_KEY_FILE_LOCATION\" end end","title":"key_file"},{"location":"application/#cert_file","text":"The cert_file of the application. class Application < Grip :: Application def cert_file : String \"SSL_CERTIFICATE_FILE_LOCATION\" end end","title":"cert_file"},{"location":"application/#run","text":"The run of the application executes the main application loop.","title":"run"},{"location":"basic_routing/","text":"Routing is the key feature which distinguishes Grip from other Crystal based web frameworks. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. get \"/\" , DemoController end end","title":"Basic routing"},{"location":"context/","text":"Context is a class which contains the Request, Response structures of an HTTP server, since Crystal Language allows us to extend its core features we have decided to add couple of helper functions to the context class. Available methods \u00b6 delete_req_header/1 delete_resp_header/1 get_req_header/1 get_resp_header/1 halt/0 merge_resp_headers/1 put_req_header/2 put_resp_header/2 put_status/1 send_resp /1 json/2 html/2 text/2 binary/2 fetch_json_params/0 fetch_query_params/0 fetch_body_params/0 fetch_file_params/0 fetch_path_params/0 delete_req_header \u00b6 Deletes a request header if present. def get ( context : Context ) : Context context . delete_req_header ( \"Referer\" ) . text ( nil ) end delete_resp_header \u00b6 Deletes a response header if present. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . delete_resp_header ( \"Content-Type\" ) end get_req_header \u00b6 Returns the values of the request header specified by key . def get ( context : Context ) : Context referer = context . get_req_header ( \"Referer\" ) context . json ( { \"referer\" => referer } ) end get_resp_header \u00b6 Returns the values of the response header specified by key . def get ( context : Context ) : Context content_type = context . get_resp_header ( \"Content-Type\" ) context . json ( { \"contentType\" => content_type } ) end halt \u00b6 Halts the function chain by closing the response stream. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . halt end merge_resp_headers \u00b6 Merges a series of response headers into the context. def get ( context : Context ) : Context context . merge_resp_headers ({ \"Content-Type\" => \"application/json\" }) . send_resp ( \"Hello, World!\" ) end put_req_header \u00b6 Adds a new request header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_req_header ( \"Referer\" , \"www.google.com\" ) . json ( \"Hello, World\" ) end put_resp_header \u00b6 Adds a new response header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_resp_header ( \"Content-Type\" , \"application/json\" ) . send_resp ( \"Hello, World!\" ) end put_status \u00b6 Assigns the given status code to the context response. def get ( context : Context ) : Context context . put_status ( 400 ) . json ( \"Bad request\" ) end send_resp \u00b6 Sends a response to the client. def get ( context : Context ) : Context context . send_resp ( \"Hello, World!\" ) end json \u00b6 Sends JSON response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . json ( \"Hello, World!\" , \"application/json; charset=UTF-8\" ) end html \u00b6 Sends HTML response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . html ( \"Hello, World!\" ) end text \u00b6 Sends text response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end binary \u00b6 Sends binary response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . binary ( \"Hello, World!\" ) end fetch_json_params \u00b6 Fetches JSON parameters from the JSON parser. def get ( context : Context ) : Context params = context . fetch_json_params context . json ( params ) end fetch_query_params \u00b6 Fetches query parameters from the query string. def get ( context : Context ) : Context params = context . fetch_query_params context . json ( params ) end fetch_body_params \u00b6 Fetches body parameters from the body parser. def get ( context : Context ) : Context params = context . fetch_body_params context . json ( params ) end fetch_file_params \u00b6 Fetches file parameters from the file parser. def get ( context : Context ) : Context params = context . fetch_file_params context . json ( params ) end fetch_path_params \u00b6 Fetches path parameters from the path parser. def get ( context : Context ) : Context params = context . fetch_path_params context . json ( params ) end","title":"Context"},{"location":"context/#available-methods","text":"delete_req_header/1 delete_resp_header/1 get_req_header/1 get_resp_header/1 halt/0 merge_resp_headers/1 put_req_header/2 put_resp_header/2 put_status/1 send_resp /1 json/2 html/2 text/2 binary/2 fetch_json_params/0 fetch_query_params/0 fetch_body_params/0 fetch_file_params/0 fetch_path_params/0","title":"Available methods"},{"location":"context/#delete_req_header","text":"Deletes a request header if present. def get ( context : Context ) : Context context . delete_req_header ( \"Referer\" ) . text ( nil ) end","title":"delete_req_header"},{"location":"context/#delete_resp_header","text":"Deletes a response header if present. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . delete_resp_header ( \"Content-Type\" ) end","title":"delete_resp_header"},{"location":"context/#get_req_header","text":"Returns the values of the request header specified by key . def get ( context : Context ) : Context referer = context . get_req_header ( \"Referer\" ) context . json ( { \"referer\" => referer } ) end","title":"get_req_header"},{"location":"context/#get_resp_header","text":"Returns the values of the response header specified by key . def get ( context : Context ) : Context content_type = context . get_resp_header ( \"Content-Type\" ) context . json ( { \"contentType\" => content_type } ) end","title":"get_resp_header"},{"location":"context/#halt","text":"Halts the function chain by closing the response stream. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . halt end","title":"halt"},{"location":"context/#merge_resp_headers","text":"Merges a series of response headers into the context. def get ( context : Context ) : Context context . merge_resp_headers ({ \"Content-Type\" => \"application/json\" }) . send_resp ( \"Hello, World!\" ) end","title":"merge_resp_headers"},{"location":"context/#put_req_header","text":"Adds a new request header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_req_header ( \"Referer\" , \"www.google.com\" ) . json ( \"Hello, World\" ) end","title":"put_req_header"},{"location":"context/#put_resp_header","text":"Adds a new response header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_resp_header ( \"Content-Type\" , \"application/json\" ) . send_resp ( \"Hello, World!\" ) end","title":"put_resp_header"},{"location":"context/#put_status","text":"Assigns the given status code to the context response. def get ( context : Context ) : Context context . put_status ( 400 ) . json ( \"Bad request\" ) end","title":"put_status"},{"location":"context/#send_resp","text":"Sends a response to the client. def get ( context : Context ) : Context context . send_resp ( \"Hello, World!\" ) end","title":"send_resp"},{"location":"context/#json","text":"Sends JSON response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . json ( \"Hello, World!\" , \"application/json; charset=UTF-8\" ) end","title":"json"},{"location":"context/#html","text":"Sends HTML response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . html ( \"Hello, World!\" ) end","title":"html"},{"location":"context/#text","text":"Sends text response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end","title":"text"},{"location":"context/#binary","text":"Sends binary response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . binary ( \"Hello, World!\" ) end","title":"binary"},{"location":"context/#fetch_json_params","text":"Fetches JSON parameters from the JSON parser. def get ( context : Context ) : Context params = context . fetch_json_params context . json ( params ) end","title":"fetch_json_params"},{"location":"context/#fetch_query_params","text":"Fetches query parameters from the query string. def get ( context : Context ) : Context params = context . fetch_query_params context . json ( params ) end","title":"fetch_query_params"},{"location":"context/#fetch_body_params","text":"Fetches body parameters from the body parser. def get ( context : Context ) : Context params = context . fetch_body_params context . json ( params ) end","title":"fetch_body_params"},{"location":"context/#fetch_file_params","text":"Fetches file parameters from the file parser. def get ( context : Context ) : Context params = context . fetch_file_params context . json ( params ) end","title":"fetch_file_params"},{"location":"context/#fetch_path_params","text":"Fetches path parameters from the path parser. def get ( context : Context ) : Context params = context . fetch_path_params context . json ( params ) end","title":"fetch_path_params"},{"location":"deployment/","text":"Heroku \u00b6 You can use heroku-buildpack-crystal to deploy your Grip application to Heroku. Cross Compilation \u00b6 Cross-compilation is supported and it can be achieved using this guide","title":"Deployment"},{"location":"deployment/#heroku","text":"You can use heroku-buildpack-crystal to deploy your Grip application to Heroku.","title":"Heroku"},{"location":"deployment/#cross-compilation","text":"Cross-compilation is supported and it can be achieved using this guide","title":"Cross Compilation"},{"location":"error_handling/","text":"Grip comes with a pre-defined error handlers for the JSON response type. You can customize the built-in error pages or even add your own using the error macro. class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context raise Grip :: Exceptions :: NotFound . new end end class NotFoundController < Grip :: Controllers :: Exception # To keep the structure of the project # we still inherit from the Base class which forces us # to define the default `call` function. def call ( context : Context ) : Context context . json ( { \"errors\" => [ context . exception . not_nil! . to_s ] } ) end end class ForbiddenController < Grip :: Controllers :: Exception def call ( context : Context ) : Context context . put_status ( 403 ) # Raised error automatically carries over the status code of the exception. . json ( { \"error\" => [ \"You lack privileges to access the current resource!\" ] } ) end end class Application < Grip :: Application def routes error 403 , ForbiddenController error 404 , NotFoundController get \"/\" , IndexController end end Keep in mind that if you won't use the Exceptions class this will just return as a normal response: class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . put_status ( 404 ) . html ( \"<p>404 Not found</p>\" ) . halt end end and this will trigger an error handler defined in the routes method of the application: class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context raise Grip :: Exceptions :: NotFound . new end end you can also raise any exception you want and handle it in the error handler like this: class ArgumentException < Grip :: Exceptions :: Base @status = HTTP :: Status :: BAD_REQUEST def initialize ( @message : String = \"Argument error\" ) end end class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context raise ArgumentException . new ( \"Something went wrong\" ) end end class BadRequestController < Grip :: Controllers :: Exception def call ( context : Context ) : Context case context . exception . not_nil! when Grip :: Exceptions :: BadRequest context . json ( { id : UUID . random . to_s , message : \"400 Bad request\" , } ) when ArgumentException context . json ( { id : UUID . random . to_s , message : \"An argument error has occured, #{ context . exception . not_nil! } \" , } ) else context . halt end end end","title":"Error handling"},{"location":"forward/","text":"Forward forwards a request to a specific route, mainly a Grip::Controllers::Base class. class Authorization < Grip :: Controllers :: Base def initialize ( @username : String , @password : String ); end def call ( context : Context ) : Context context end end class Application < Grip :: Application def routes # Forward macro simply routes the matched requests to a certain Base controller # which contains a single call/1 function. forward \"/\" , Authorization , username : \"admin\" , password : \"admin\" end end","title":"Forward"},{"location":"getting_started/","text":"1.Init a Crystal project. crystal init app demo && cd demo 2.Add the dependency to your shard.yml and run shards install . dependencies : grip : github : grip-framework/grip 3.Write down the following code in src/demo.cr . require \"grip\" class DemoController < Grip :: Controllers :: Http def get ( context : Context ) context . put_status ( 201 ) # Put a response status code. . put_resp_header ( \"Server\" , \"TornadoServer/6.0.4\" ) # Put a response header. . json ( # Respond with JSON encoded data. { \"id\" => 1 } ) end end class Application < Grip :: Application def routes get \"/\" , DemoController end end app = Application . new app . run 4.Run server. crystal src/demo.cr 5.Send request. curl \"http://0.0.0.0:5000/\" 6.Auto restart server. # Use nodemon to watch file changed and auto restart server. sudo npm install -g nodemon nodemon -e \"cr,yml\" --exec \"crystal run\" src/demo.cr","title":"Getting Started"},{"location":"installation/","text":"Add this to your application's shard.yml : dependencies : grip : github : grip-framework/grip And run this command in your terminal: shards install","title":"Installation"},{"location":"intermediate_routing/","text":"The routing mechanism is based on Kemal which uses the radix tree implementation to identify the URL patterns. class DemoController < Grip :: Controllers :: Http def index ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism, the `as` keyword creates a Proc(Context, Context) and wraps it around # the index/1 function f the DemoController. get \"/\" , DemoController , as : :index end end","title":"Intermediate routing"},{"location":"pipe_middleware/","text":"Pipe middleware is the building block of the framework. Creating a custom pipe is as easy as creating an HTTP handler : class DemoPipe include HTTP :: Handler # Keep in mind calling the call_next() function is prohibited here. def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context # Mutate the context and pass it on to the next handler. end end class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes # Creating a pipeline with a single pipe to be routed through. pipeline :web , [ DemoPipe . new ] pipeline :api , [ DemoPipe . new ] scope \"/\" do pipe_through :web get \"/\" , DemoController scope \"/users\" do # This will go through [:web, :api]. pipe_through :api get \"/\" , DemoController end end end end Advantage of the pipe over a raw middleware is that you can controll which routes go through the middleware and which don't.","title":"Pipe middleware"},{"location":"raw_middleware/","text":"In Grip raw middlewares are mentioned as handlers, when creating a handler you include the HTTP::Handler module and define a call/1 function. class DemoHandler include HTTP :: Handler def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context # Mutate the context and pass it on to the next handler. end end class Application < Grip :: Application # These are inserted after the exception handler def custom : Array ( HTTP :: Handler ) [ DemoHandler . new ] of HTTP :: Handler end # These are inserted before the exception handler def root : Array ( HTTP :: Handler ) [ DemoHandler . new ] of HTTP :: Handler end end","title":"Raw middleware"},{"location":"runtime_flags/","text":"Configuration flags \u00b6 1.Flag which disables the exception page: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D hideAllExceptions Environment flags \u00b6 1.Flag which switches the environment to testing: # -D is used to define a compile time flag. crystal run ./src/application.cr -D test","title":"Runtime flags"},{"location":"runtime_flags/#configuration-flags","text":"1.Flag which disables the exception page: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D hideAllExceptions","title":"Configuration flags"},{"location":"runtime_flags/#environment-flags","text":"1.Flag which switches the environment to testing: # -D is used to define a compile time flag. crystal run ./src/application.cr -D test","title":"Environment flags"},{"location":"scope/","text":"Scope defines a prefix for routes which will be nested in a block. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The route gets built from the ground starting from the lowest GET /, to the top /api/v1. scope \"/api/v1\" do get \"/\" , DemoController scope \"/users\" do get \"/\" , DemoController end end end end","title":"Scope"},{"location":"ssl/","text":"Grip has built-in and easy to use SSL support, it can be configured easily and deployed instantly. To start your Grip application with SSL support, use: KEY = PATH_TO_THE_KEY CERTIFICATE = PATH_TO_THE_CERTIFICATE crystal run ./src/application.cr -Dwith_openssl","title":"SSL"},{"location":"swagger/","text":"Swagger is in essence an Interface Description Language for describing RESTful APIs expressed using JSON. Swagger is used together with a set of open-source software tools to design, build, document, and use RESTful web services. The class with documentation: alias Document = Grip :: Annotations @ [ Document :: Controller ( description : \"An example HTTP controller\" ) ] class HttpController < Grip :: Controllers :: Http # See these documents for more information: # https://github.com/grip-framework/grip/blob/master/src/grip/dsl/macros.cr # https://github.com/icyleaf/swagger/ @ [ Document :: Route ( description : \"This is a description.\" , summary : \"This route returns a response.\" , parameters : [] of Swagger :: Parameter , # https://github.com/icyleaf/swagger/blob/master/src/swagger/parameter.cr responses : [] of Swagger :: Response , # https://github.com/icyleaf/swagger/blob/master/src/swagger/response.cr request : nil , # https://github.com/icyleaf/swagger/blob/master/src/swagger/request.cr authorization : false , deprecated : false ) ] def get ( context : Context ) : Context context . halt end end The application which instructs the swagger macro to document the class: class Application < Grip :: Application def routes scope \"/api\" do forward \"/swagger/*\" , Grip :: ThirdParty :: Swagger :: Interface , document : document (), base_path : \"/api/swagger\" get \"/\" , HttpController end end end","title":"Swagger"},{"location":"testing/","text":"1.Add spec-grip to your shard.yml file as a dependencie. dependencies : grip : github : grip-framework/grip spec-grip : github : grip-framework/spec-grip 2.Then run shards to get the dependencies: $ shards install 3.Now you should require it before your files in your spec/spec_helper.cr require \"spec-grip\" require \"../src/your-grip-app\" For example, your Grip application: # src/your-grip-app.cr require \"grip\" class Index < Grip :: Controllers :: Http def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes get \"/\" , Index end end app = Application . new app . run 4.Now you can easily test your Grip application in your specs. crystal spec -Dtest # spec/your-grip-app-spec.cr describe \"Your::Grip::App\" do # You can use get,post,put,patch,delete to call the corresponding route. it \"renders /\" do get \"/\" do | response | response . body . should eq \"Hello, World!\" end end end","title":"Testing"},{"location":"verbs/","text":"There are several HTTP verbs supported by the router: class Application < Grip :: Application def routes get \"/\" , DemoController # Routes all the `GET /` requests to DemoController.get/1 post \"/\" , DemoController # Routes all the `POST /` requests to DemoController.post/1 put \"/\" , DemoController # Routes all the `PUT /` requests to DemoController.put/1 delete \"/\" , DemoController # Routes all the `DELETE /` requests to DemoController.delete/1 patch \"/\" , DemoController # Routes all the `PATCH /` requests to DemoController.patch/1 head \"/\" , DemoController # Routes all the `HEAD /` requests to DemoController.head/1 options \"/\" , DemoController # Routes all the `OPTIONS /` requests to DemoController.options/1 end end","title":"Available verbs"},{"location":"web_socket_routing/","text":"WebSockets are easy to define and use thanks to the core team of the Crystal Programming Language. class DemoController < Grip :: Controllers :: WebSocket def on_open ( context : Context , socket : Socket ) : Void # Executed when a client opens a connection to the server. end def on_message ( context : Context , socket : Socket , message : String ) : Void # Executed when a client sends a message. end def on_ping ( context : Context , socket : Socket , message : String ) : Void # Executed when a client pings the server. end def on_pong ( context : Context , socket : Socket , message : String ) : Void # Executed when a server receives a pong. end def on_binary ( context : Context , socket : Socket , binary : Bytes ) : Void # Executed when a client sends a binary message. end def on_close ( context : Context , socket : Socket , error_code : HTTP :: WebSocket :: CloseCode | Int ?, message : String ) : Void # Executed when a client closes the connection to the server. end end class PoweredByHeader include HTTP :: Handler def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context context . put_resp_header ( \"Server\" , \"grip\" ) end end class SecureHeaders include HTTP :: Handler def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context context . put_resp_header ( \"Security\" , \"Absolutely\" ) end end class Application < Grip :: Application def routes pipeline :api , [ PoweredByHeader . new ] pipeline :web , [ SecureHeaders . new ] # WebSockets support the pipeline routing, keep in mind that # the `:id` URL here gives an option to fetch the `id` using the # `context : Context.fetch_path_params/0` function. scope \"/\" do pipe_through :web pipe_through :api ws \"/:id\" , DemoController end end end","title":"WebSocket routing"}]}